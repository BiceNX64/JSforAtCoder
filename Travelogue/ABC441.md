# 📝 ABC441 振り返り(2026-01-18)

AB2完でした。

| 順位 | ユーザ                                     | 得点             | A                                                            | B                                                            | C    | D    | E    | F    | G    |
| ---- | ------------------------------------------ | ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---- | ---- | ---- | ---- | ---- |
| 7679 | [ **Bice**](https://atcoder.jp/users/Bice) | **300** (2)38:18 | [**100**](https://atcoder.jp/contests/abc441/submissions/72503046) (1)3:47 | [**200**](https://atcoder.jp/contests/abc441/submissions/72527493) (1)28:18 | (3)  | -    | -    | -    | -    |

2025-11-15から9回参加していますが、いまのところ毎回AB2完止まりです。まずは茶色レーティング入りしたいですが、そのためにC問題を解けるようになる必要があります。今回もCは解けなかったのですがケアレスミスでお手つきを2回してしまったのがもったいなかったです。

### 🏆 コンテスト成績

| 項目               | 内容                                                         |
| ------------------ | ------------------------------------------------------------ |
| **ユーザ名**       | [**Bice**](https://atcoder.jp/users/Bice)                    |
| **コンテスト名**   | [AtCoder Beginner Contest 441 (Promotion of Engineer Guild Fes)](https://atcoder.jp/contests/abc441) |
| **順位**           | [7679th](https://atcoder.jp/contests/abc441/standings?watching=Bice) / 12331 |
| **パフォーマンス** | 325                                                          |
| **レーティング**   | **138** → **157** (+19) Highest更新！                        |
| **段級位**         | **11 級** → **10 級**                                        |

## 📈 レーティングについての考察

レーティングは母集団の状況によるそうなので参考値ですが、今回上述のようにお手つきを2回したにもかかわらず、これまでで一番値が大きかったです。ちなみにABだとスコアは300点なのですが、今回400点(AC2完)の一番遅いひとのパフォーマンスは500くらいでした。茶色のレーティングが400なので、やはりC問題が解けるかどうかが茶色のハードルになるようです。

A、B、Cの問題をGeminiのアドバイスを参考にレビューしていきます(問題文の掲載は著作権等の関係で控えさせていただきます。Linkから確認してください)。

## 🔠 [ABC441-A](https://atcoder.jp/contests/abc441/tasks/abc441_a)

```javascript
// ABC441
// https://atcoder.jp/contests/abc441/tasks/abc441_a
// 2026-01-17

"use strict";
const fs = require('fs');

function Main(input) {
    const args = input.trim().split(/\s+/);
    let cur = 0;
    const next = () => args[cur++];
    const nextNum = () => Number(next());
    const nextBigInt = () => BigInt(next());
    // const lines = input.replace(/\r/g, '').trim().split(/\n/);

    // 👇️ ロジックを記述 👇️

    const P = nextNum();
    const Q = nextNum();
    const X = nextNum();
    const Y = nextNum();

    if (X >= P && X < P + 100 && Y >= Q && Y < Q + 100) {
        console.log("Yes");
    } else {
        console.log("No");
    }

    // 👆️ ロジックを記述 👆️
}

Main(require("fs").readFileSync(process.platform === 'linux' ? "/dev/stdin" : process.argv[2], "utf8"));
```

この問題でお手つきをしてしまったのですが、if文のなかの条件でXとYの上限に等しいを含めてしまいました。

また同じif文の条件の連結で`&&`とするところをタイポで`&`としてしまいました。Geminiによると「**JavaScriptでは、実は `&` でも偶然動いてしまうことがあるのですが（trueが1、falseが0として計算されるため）、これはバグの温床になるので絶対に避けるべきです。**」とのことでした。今回はたまたまACとなりましたが、要注意です。

```
& ： ビットごとのAND。これは数字のビット計算（2進数）に使う。
```

問題自体に特に難しさはないですが、その分ケアレスミスが目立ってしまいました。

## 🔠 [ABC441-B](https://atcoder.jp/contests/abc441/tasks/abc441_b)

```javascript
// ABC441
// https://atcoder.jp/contests/abc441/tasks/abc441_b
// 2026-01-17

"use strict";
const fs = require('fs');

function Main(input) {
    const args = input.trim().split(/\s+/);
    let cur = 0;
    const next = () => args[cur++];
    const nextNum = () => Number(next());
    const nextBigInt = () => BigInt(next());
    // const lines = input.replace(/\r/g, '').trim().split(/\n/);

    // 👇️ ロジックを記述 👇️

    const N = nextNum();
    const M = nextNum();
    const S = new Set(next());
    const T = new Set(next());
    const Q = nextNum();
    const W = [];
    for (let i = 0; i < Q; i++) {
        W.push(next());
    }
    const ans = [];
    for (let i = 0; i < Q; i++) {
        const word = W[i].split("");
        let isTakahashi = true;
        let isAoki = true;

        for (let j = 0; j < word.length; j++) {
            if (!S.has(word[j])) {
                isTakahashi = false;
                break;
            }
        }
        for (let k = 0; k < word.length; k++) {
            if (!T.has(word[k])) {
                isAoki = false;
                break;
            }

        }
        if (isTakahashi && !isAoki) {
            ans.push("Takahashi");
        } else if (!isTakahashi && isAoki) {
            ans.push("Aoki")
        } else {
            ans.push("Unknown")
        }
    }

    console.log(ans.join("\n"))

    // 👆️ ロジックを記述 👆️
}

Main(require("fs").readFileSync(process.platform === 'linux' ? "/dev/stdin" : process.argv[2], "utf8"));
```

この問題のポイントは`set`と`has()`のメソッドを使い指定の文字列の文字を含むかどうかの真偽を把握し、その真偽の組み合わせの条件に応じて回答を出力することでした。Geminiから指摘されたのがSetの使い方でした。

```javascript
// Setに文字列を渡せば1文字ずつ分解して取り込むので1行でOK
const S = new Set(next());

// わたしは以下の2行で書いていましたが、上の1行で書くべきでした。
// const S = [next().split("")];
// const setS = new Set(...S);
```

また、最後の出力に関してはforループで`console.log()`を何度も呼び出していたのですが、出力が数万行($10^4 \sim$)を超えてくると**TLEとなるリスクがあるため要注意**、とのことです。

```javascript
// for (let i = 0; i < ans.length; i++) {
//     console.log(ans[i]);
// }
console.log(ans.join("\n"))
```

AtCoderでよくある制約、$N = 2 \times 10^5$ (20万行) のデータを出力する場合で比べると以下の通り。

| 出力方法                            | 実行時間 (目安)        | 競プロでの判定                  |
| ----------------------------------- | ---------------------- | ------------------------------- |
| **`console.log` をループで 20万回** | **約 1.5秒 〜 3.0秒**  | ⚠️ **TLE (時間切れ) の危険大！** |
| **`join("\n")` で 1回だけ出力**     | **約 0.05秒 〜 0.1秒** | ✅ **余裕で AC (爆速)**          |

このあたりの処理速度にクリティカルな処理はまとめておき、今後に活かせるようにしたいと思います。

この問題では、配列を改行で区切らずにそのまま出力するコードを提出してしまうという初歩的なケアレスミスでお手つきとなってしまいました。今回は母集団のコンディションがわたしのレベル周辺ではパフォーマンスを出しやすかったらしいだけにABそれぞれでお手つきをしたのはもったいなかったです。

## 🔠 [ABC441-C](https://atcoder.jp/contests/abc441/tasks/abc441_c)

```javascript
// ABC441
// https://atcoder.jp/contests/abc441/tasks/abc441_c
// 2026-01-17

"use strict";
const fs = require('fs');

function Main(input) {
    const args = input.trim().split(/\s+/);
    let cur = 0;
    const next = () => args[cur++];
    const nextNum = () => Number(next());
    const nextBigInt = () => BigInt(next());
    // const lines = input.replace(/\r/g, '').trim().split(/\n/);

    // 👇️ ロジックを記述 👇️ 

    const N = nextNum();
    const K = nextNum();
    const X = nextNum();
    const A = [];
    for (let i = 0; i < N; i++) {
        A.push(nextNum());
    }

    const sortA = A.sort((a, b) => b - a);

    let sum = 0;
    let cups = 0;
    let found = false;
    for (let i = N - K; i < N; i++) {
        sum += sortA[i];
        if (sum >= X) {
            console.log(i + 1);
            return;
        }
    }

    console.log(-1)

    // 👆️ ロジックを記述 👆️
}

Main(require("fs").readFileSync(process.platform === 'linux' ? "/dev/stdin" : process.argv[2], "utf8"));
```

わたしは出力例1の文章説明をみて、いろんな組み合わせを考慮しなければいけないものだと勘違いしてしまい、問題を読み違えていたところがあったのですが、求められていることは単純で、

> 確実に X ml 以上の日本酒を飲むためには、最低何個のカップを選ぶ必要があるか

です。なので、最悪のケースを想定してその場合の最善を考えればよく、具体的な解法としては、

- まずたくさん入っているカップの順番に並べる(Aを降順にソートする)
- たくさん入っているもの上位N-K個はすべて水のカップだとする(全N個からお酒K個を引く→N-K個が水)
- そうすると、残りのN-K+1からN個目までのカップはすべてお酒になる
- なので、N-K+1個目から日本酒を飲んで行き、X以上になればそこが解 (N-K+1からN個目まで全部飲んでもX以上にならなければ解なしで-1)

でした。たまたまテストケースが3つともクリアできたため、問題の理解の間違いに気づけずに終わってしまいました。考え方もその実装も難しくなかっただけにACしたかったです。